<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/autocomposer-melody.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="https://github.com/rjsalvadorr/autocomposer-melody.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/autocomposer-data.js~AutoComposerData.html">AutoComposerData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/autocomposer-melody.js~AutoComposerMelody.html">AutoComposerMelody</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/autocomposer-parser.js~AutoComposerParser.html">AutoComposerParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/chord-unit.js~ChordUnit.html">ChordUnit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/melody-unit.js~MelodyUnit.html">MelodyUnit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/score-writer.js~ScoreWriter.html">ScoreWriter</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/autocomposer-melody.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">var tonal = require(&apos;tonal&apos;);
var ChordUnit = require(&apos;./chord-unit&apos;);
var MelodyUnit = require(&apos;./melody-unit&apos;);

var AutoComposerData = require(&apos;./autocomposer-data&apos;);
var AcData = new AutoComposerData.AutoComposerData();

/**
 * Creates melodies from a given chord progression
 */
class AutoComposerMelody {
  /**
  * @param {string[]} chordProgression - array of chord symbols
  * @param {string} lowerLimit - lower boundary note (in scientific notation)
  * @param {string} upperLimit - upper boundary note (in scientific notation)
  */
  constructor(chordProgression, lowerLimit, upperLimit) {
    /** @type {string[]} */
    this.chordProgression = chordProgression || AcData.INITIAL_PROGRESSION,
    /** @type {string} */
    this.lowerLimit = lowerLimit || AcData.DEFAULT_LOWER_LIMIT,
    /** @type {string} */
    this.upperLimit = upperLimit || AcData.DEFAULT_UPPER_LIMIT
  }

    /**
    * For a given note, find its lowest instance in the specified range.
    * @private
    * @param {string} note - note (written in scientific notation)
    * @param {string} upperLimit - note (written in scientific notation)
    * @param {string} lowerLimit - note (written in scientific notation)
    * @return {string[]} - an array of notes (written in scientific pitch)
    */
  getLowestNoteInRange(note, upperLimit, lowerLimit) {
    return [];
  }

    /**
    * For a given chord, get all the chord tones between the upper and lower limits.
    * @private
    * @param {string} chord - chord symbol
    * @param {string} lowerLimit - note (written in scientific notation)
    * @param {string} upperLimit - note (written in scientific notation)
    * @return {string[]} - an array of notes (written in scientific pitch)
    */
  getAllChordTones(chord, lowerLimit, upperLimit) {
    var chordTones = tonal.chord(chord);
    var chordTonesInRange = tonal.range.pitchSet(chordTones, [lowerLimit, upperLimit]);

    for(var i = 0; i &lt; chordTonesInRange.length; i++) {
      for(var j = 0; j &lt; chordTones.length; j++) {
        // Fixing pesky issue where D7 was returned as &quot;D Gb A C&quot; instead of &quot;D F# A C&quot;
        // If the current chord tone is enharmonic with the note from the pitch set,
        // Override it with the chord tone.
        if(tonal.note.pc(chordTonesInRange[i]) != chordTones[j]
          &amp;&amp; tonal.note.enharmonics(chordTones[j]).indexOf(tonal.note.pc(chordTonesInRange[i])) &gt; -1) {
          chordTonesInRange[i] = chordTones[j] + tonal.note.oct(chordTonesInRange[i]);
        }
      }
    }

    return chordTonesInRange;
  }

    /**
    * For a given chord symbol, creates a ChordUnit object
    * @private
    * @param {string} chord - chord symbol
    * @param {string} lowerLimit - note (in scientific notation)
    * @param {string} upperLimit - note (in scientific notation)
    * @return {ChordUnit}
    */
  buildChordUnit(chord, lowerLimit, upperLimit) {
    var chordTonesInRange = this.getAllChordTones(chord, lowerLimit, upperLimit);
    var chordUnit = new ChordUnit.ChordUnit(chord, chordTonesInRange, null);
    return chordUnit;
  }

    /**
    * For a given melody, creates a MelodyUnit object
    * @private
    * @param {string[]} chordProgression - a chord progression
    * @param {string} melodyString - a melody (in scientific notation)
    * @return {MelodyUnit}
    */
  buildMelodyUnit(chordProgression, melodyString) {
    var arrMelody = melodyString.split(&quot; &quot;);
    var melodyUnit = new MelodyUnit.MelodyUnit(chordProgression, arrMelody);
    return melodyUnit;
  }

    /**
    * For a given chord progression, generate a series of melodies that fit over the progression
    * @private
    * @param {string[]} chordProgression - chord symbols
    * @param {string} lowerLimit - lower limit (in scientific notation). Optional value.
    * @param {string} upperLimit - upper limit (in scientific notation). Optional value.
    * @return {ChordUnit[]} - a list of ChordUnit objects.
    */
  buildChordUnitList(chordProgression, lowerLimit, upperLimit) {
    if(lowerLimit == null) {
      lowerLimit = this.lowerLimit;
    }
    if(upperLimit == null) {
      upperLimit = this.upperLimit;
    }

    var chordUnitList = [];
    var chordTonesInRange;

    for(var i = chordProgression.length - 1; i &gt;= 0; i--) {
      chordTonesInRange = this.getAllChordTones(chordProgression[i], lowerLimit, upperLimit);

      if(i === chordProgression.length) {
        chordUnitList[i] = new ChordUnit.ChordUnit(chordProgression[i], chordTonesInRange, null);
      } else {
        chordUnitList[i] = new ChordUnit.ChordUnit(chordProgression[i], chordTonesInRange, chordUnitList[i + 1]);
      }
    }

    return chordUnitList;
  }

    /**
    * Recursive function that adds new notes to the previous notes passed into it.
    * On the first call of this function, melodyList should be null.
    * @private
    * @param {ChordUnit} chordUnit - the ChordUnit for the next chord
    * @param {?string[]} melodyList - list of existing melodies
    * @param {Object} options - if true, generated melodies will be filtered
    * @param {boolean} options.filtered - if true, generated melodies will be filtered
    * @param {boolean} options.rawOutput - if true, generated melodies will be given as strings
    * @return {string[]} - a list of melodies. Each element is a string represeting a melody. Each melody string is written as a series of pitches delimited by a space.
    */
  getMelodiesCore(chordUnit, melodyList, options) {
    var returnList = [];
    var chordTones = chordUnit.chordTones;
    var rawMelody, newMelody;
    var haxThis = this;

    if(melodyList) {
      // We&apos;re somewhere along the middle of the chain.
      melodyList.forEach(function(currentMelody) {
        chordTones.forEach(function(currentChordTone) {
          newMelody = currentMelody + &quot; &quot; + currentChordTone;

          if(options.filtered) {
            if(AcData.filterMelodyRange(newMelody)) {
              returnList.push(newMelody);
            }
          } else {
            returnList.push(newMelody);
          }

        });
      });
    } else {
      // This is the beginning of the chain.
      melodyList = chordUnit.chordTones;
      returnList.push.apply(returnList, melodyList);
    }

    if(chordUnit.nextChordUnit) {
      // We&apos;re somewhere along the middle of the chain.
      return this.getMelodiesCore(chordUnit.nextChordUnit, returnList, options);
    } else {
      // End of the chain.
      return returnList;
    }
  }

    /**
    * For a given chord progression, generate a series of melodies that fit over the progression.
    * @param {string[]} chordProgression - chord progression given by user
    * @return {MelodyUnit[]} - an array of notes (written in scientific pitch)
    */
  getAllMelodies(chordProgression) {
    var chordUnitList = this.buildChordUnitList(chordProgression, this.lowerLimit, this.upperLimit);
    var melodies = this.getMelodiesCore(chordUnitList[0], null, {filtered: false});

    var melodyUnits = [];
    var haxThis = this;
    melodies.forEach(function(rawMelody) {
      melodyUnits.push(haxThis.buildMelodyUnit(chordProgression, rawMelody));
    });

    return melodyUnits;
  }

    /**
    * For a given chord progression, generate a series of melodies that fit over the progression.
    * @param {string[]} chordProgression - chord progression given by user
    * @return {string[]} - an array of notes (written in scientific pitch)
    */
  getRawMelodies(chordProgression) {
    var chordUnitList = this.buildChordUnitList(chordProgression, this.lowerLimit, this.upperLimit);
    var melodies = this.getMelodiesCore(chordUnitList[0], null, {filtered: true, rawOutput: true});

    return melodies;
  }

    /**
    * For a given chord progression, generate a series of melodies that fit over the progression.
    * @param {string[]} chordProgression - chord progression given by user
    * @return {MelodyUnit[]} - an array of MelodyUnits
    */
  getMelodies(chordProgression) {
    var chordUnitList = this.buildChordUnitList(chordProgression, this.lowerLimit, this.upperLimit);
    var melodies = this.getMelodiesCore(chordUnitList[0], null, {filtered: true});

    var melodyUnits = [];
    var haxThis = this;
    melodies.forEach(function(rawMelody) {
      melodyUnits.push(haxThis.buildMelodyUnit(chordProgression, rawMelody));
    });

    return melodyUnits;
  }

};

exports.AutoComposerMelody = AutoComposerMelody;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
